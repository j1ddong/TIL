# 스케줄링 시스템

 운영체제는 CPU를 효율적으로 사용하기 위해 프로세스 스케줄링을 수행하며, 스케줄링 시스템은  `배치(batch) 처리 시스템, 시분할 시스템, 멀티 태스킹, 멀티 프로세싱, 멀티 프로그래밍`으로 나눌 수 있다. 

## Multi-programming

> 현재 실행중인 프로그램 I/O로 인해 대기, I/O 장치에서 기다리던 데이터 도착했을 때, 현재 실행중인 프로그램이 완료됐을 때 CPU가 이동한다. 

프로세스가 I/O 작업을 하러 갈 때, 프로세서의 처리 속도와 입출력 속도 간의 차이로 인해 자원낭비가 이루어진다. 이를 방지하기 위해 다른 프로세스에게 CPU 할당하는 방식으로 프로세서를 효율적으로 사용할 수 있다.

## Time Sharing

> CPU가 일정시간동안 프로그램을 번갈아가면서 실행, 대표적으로 라운드로빈 방식이 있다

- 라운드로빈 스케줄링: 각 프로세스에 일정시간을 할당하고, 할당된 시간이 지나면 그 프로세스는 `ready queue`의 끝으로 밀려나게 된다. 문맥 전환의 오버헤드가 큰 반면 응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리하다.

### Multi-processing, Multi-tasking, Batch

- Multi-processing: 다수의 프로세서(CPU)가 서로 협력적으로 일을 처리하는 것을 의미

- Multi-tasking: 하나의 CPU안에서 Task(운영체제에서 처리하는 작업의 단위 또는 정해진 일을 수행하기 위한 명령어 집합)을 번갈아가면서 수행하는 것을 의미
  
  - 멀티 태스킹은 시분할 시스템에서 사용되며, 사용자에게 다수의 작업이 동시에 처리되는 것처럼 느끼게 할 수 있다.

- Batch: 큐 자료구조와 같은 FIFO 방식이고, 실행 요청 순서에 따라 순차적으로 실행하는 방식이다.

# 스케줄러

> 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할

## Scheduling Queue 3가지

> 프로세스를 스케줄링하기 위한 Queue 에는 세 가지 종류가 존재한다.

- Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합

- Ready Queue : 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합 == ready상태인 프로세스들

- Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

---

각각의 Queue 에 프로세스들을 넣고 빼주는 스케줄러에도 크게 **세 가지 종류가** 존재한다.

## 장기 스케줄러 (long-term scheduler | job scheduler)

6개 일을 올릴 수 있는 메모리가 있는데, 10개의 일을 수행해야한다고 하자. 장기 스케쥴러는 10개 중에 6개를 고르는 역할을 한다. 

> 메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool 에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue 로 보낼지 결정하는 역할을 한다.

- 메모리와 디스크 사이의 스케줄링을 담당.

- 프로세스에 memory(및 각종 리소스)를 할당(admit)

- degree of Multiprogramming 제어  (실행중인 프로세스의 수 제어)

- 프로세스의 상태 new -> ready(in memory)

- [ ] 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.

## 단기 스케줄러 (short-term scheduler | CPU scheduler)

메모리에 올라와있는 6개의 작업 중에 CPU에게 배정할 한가지 일을 고르는 것이 단기스케쥴러가 하는 일이다.

- CPU와 메모리 사이의 스케줄링을 담당함
- ready queue에 있는 프로세스를 running상태로 바꿀 지 결정하는 역할  
  (ready -> running -> waiting -> ready)
- 프로세스에 CPU를 할당하는 역할을 함(scheduler dispatch)

<img src="file:///C:/Users/jiunHan/AppData/Roaming/marktext/images/2022-08-09-18-36-34-image.png" title="" alt="" width="658">

## 중기 스케줄러 (midium-term scheduler | Swapper)

> 너무 많은 프로세스에게 메모리가 할당해 시스템 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스 수를 동적으로 조절하기 위해 추가된 스케쥴러이다.

- degree of multiprogramming 제어
- 여유공간 마련을 위해 프로세스를 메모리에서 디스크로 쫓아냄(swapping)
- 프로세스에게서 메모리를 deallocate(할당 해제)
- 현 시스템에서 메모리에 너무많은 프로그램이 올라가는 것을 조절하는 스케줄러
- 프로세스의 상태 ready -> suspended
- 스와핑(Swapping) : 일부 프로세스를 메모리에서 디스크로 보내고(swap-out), 시간이 흘러 메모리에 여유가 생기면 다시 적재(swap-in)한다

---

# 가상 메모리

> 다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

#### 프로그램의 일부분만 메모리에 올릴 수 있다면...

- 물리 메모리 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다.
- swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.

### 가상 메모리가 하는 일

- 가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 `가상 주소 공간`을 프로그래머에게 제공할 수 있다.

- 운영체제는 CPU에서 당장 수행해야 할 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 `스왑 영역(Swap Area)` 에 내려놓았다가 다시 필요해지면 메모리에 올라가 있는 부분과 교체하는 방식을 사용한다.

- 가상 메모리 크기 = 물리 메모리 + 스왑 영역

- 가상 주소를 참조할 때마다 매번 이를 물리 주소로 변환을 하게 되니까 이 시간을 짧게 하려고 **MMU**라는 하드웨어 칩의 지원을 받는다. MMU는 가상 주소를 물리 주소로 빠르게 변환해주는 역할을 한다.

![](C:\Users\jiunHan\AppData\Roaming\marktext\images\2022-08-09-21-30-35-image.png)

#### 가상 주소 공간

- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.
- 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

| `Stack` | free (60KB) | `Heap` | `Data` | `Code` |
| ------- | ----------- | ------ | ------ | ------ |

### Demand Paging(요구 페이징)

> 프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, 가상 메모리 시스템에서 많이 사용된다. 즉 프로세스의 데이터를 모두 메모리에 올리지 않고 실행 중 필요한 시점에서 메모리에 적재하는 기법

- 가상 메모리는 대개 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. **한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.**
  
  - 페이징(Paging System): 프로세스가 사용하는 메모리 공간을 잘게 나누어서 비연속적으로 실제 메모리에 할당하는 메모리 관리 기법이다. 이 잘게 나눈 것의 단위가 페이지이다.
  
  - 프로세스 PCB에 Page Table 구조체를 가리키는 주소가 들어있고 여기에는 가상[페이지]-물리[프레임] 주소간 매핑 정보가 있다.
  
  ![](C:\Users\jiunHan\AppData\Roaming\marktext\images\2022-08-09-21-23-59-image.png)

- 프로세스 내의 개별 페이지들은 `페이저(pager)`에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, **사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.**

### 페이지 폴트 인터럽트 (Page Fault Interrupt)

- 프로그램에 대한 모든 내용이 물리 메모리에 올라오지 않기 때문에 메모리에 없는 페이지에 접근하려 할 때 페이지 폴트가 발생한다. 

- 페이지 폴트가 발생하면 원하는 페이지를 보조 저장 장치에서 가져오게 되고 만약 물리 메모리가 가득 차 있는 상태라면 페이지 교체가 이루어진다.

### 페이지 교체

#### 기본적인 방법

물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름이다.

1. 디스크에서 필요한 페이지의 위치를 찾는다
2. 빈 페이지 프레임을 찾는다.
   1. `페이지 교체 알고리즘`을 통해 희생될(victim) 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

#### 페이지 교체 알고리즘

##### FIFO 페이지 교체

가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in first-out)의 흐름을 가진다. 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다는 것이다.

- 장점
  
  - 이해하기도 쉽고, 프로그램하기도 쉽다.

- 단점
  
  - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다(초기 변수 등)
  - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
  - `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

##### 최적 페이지 교체(Optimal Page Replacement)

`Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다. 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다. 주로 비교 연구 목적을 위해 사용한다.

- 장점
  
  - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.

- 단점
  
  - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

##### LRU 페이지 교체(LRU Page Replacement)

`LRU: Least-Recently-Used`  
최적 알고리즘의 근사 알고리즘으로, 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.

- 특징
  - 대체적으로 `FIFO 알고리즘`보다 우수하고, `OPT알고리즘`보다는 그렇지 못한 모습을 보인다.

##### LFU 페이지 교체(LFU Page Replacement)

`LFU: Least Frequently Used`  
참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘이다.

- 특징
  - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다, 다른 기능을 사용하게되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다
  - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

##### MFU 페이지 교체(MFU Page Replacement)

`MFU: Most Frequently Used`  
참조 회수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.

- 특징
  - 최적(OPT) 페이지 교체를 제대로 근사하지 못하기 때문에, 잘 쓰이지 않는다.

-참고 사이트-

[Interview_Question_for_Beginner/OS at master · JaeYeopHan/Interview_Question_for_Beginner · GitHub](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#paging%ED%8E%98%EC%9D%B4%EC%A7%95)

[[운영체제OS] 장기스케줄러 vs 중기스케줄러 vs 단기스케줄러에 대해 알아보자! long, medium, short scheduler 차이점 들어봤뉘](https://jhnyang.tistory.com/372)

[CS - OS - 07. 가상 메모리](https://eclipsemode.tistory.com/79)


